"""
Test that school sizes are being generated by school type when with_school_types is turned on and data is available.
"""

import sciris as sc
import synthpops as sp
import numpy as np
import matplotlib as mplt
import matplotlib.pyplot as plt
import cmasher as cmr
import cmocean
import pytest

import covasim as cv

mplt.rcParams['font.family'] = 'Roboto Condensed'
mplt.rcParams['font.size'] = 7


# parameters to generate a test population
pars = sc.objdict(
    n                               = 5e1,
    rand_seed                       = 123,

    country_location                = 'usa',
    state_location                  = 'Washington',
    location                        = 'seattle_metro',
    use_default                     = True,

    smooth_ages                     = True,
    window_length                   = 7,
    household_method                = 'infer_ages',

    with_industry_code              = 0,
    with_facilities                 = 0,
    with_non_teaching_staff         = 1,
    use_two_group_reduction         = 1,
    with_school_types               = 1,

    school_mixing_type              = {'pk': 'age_and_class_clustered', 'es': 'age_and_class_clustered', 'ms': 'age_and_class_clustered', 'hs': 'random', 'uv': 'random'},  # you should know what school types you're working with
)


def test_cannot_change_attribute():
    sp.logger.info("Test to show that class methods can't be easily reset.")
    pop = sp.Pop(**pars)
    pop.household = sp.Household()
    with pytest.raises(ValueError) as excinfo:
        pop.household.set_household = 1
    assert "exists as an attribute, so cannot be set as key; use setattribute() instead" in str(excinfo.value), 'Check that you cannot reset an attribute or household class method failed.'
    print('Check passed. Could not reset household class method as an integer.')

    pop.households = sp.Households()
    with pytest.raises(ValueError) as excinfo:
        pop.households.add_household = 2
    assert "exists as an attribute, so cannot be set as key; use setattribute() instead" in str(excinfo.value), 'Check that you cannot reset an attribute or households class method failed.'
    print('Check passed. Could not reset households class method as an integer.')


def test_empty_household():
    sp.logger.info("Test creating an empty household.")

    household = sp.Household()

    def check_phrase(key, value, passed):
        if passed:
            print(f"Check passed. household {key} for an empty household is {value}.")
        else:
            print(f"Check failed. household {key} for an empty household is {value}.")

    assert household.get_hhid() is None, check_phrase('hhid', household.get_hhid(), passed=False)
    check_phrase('hhid', household.get_hhid(), passed=True)

    np.testing.assert_array_equal(household.get_member_uids(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_uids.", verbose=True)
    check_phrase('member_uids', household.get_member_uids(), passed=True)

    np.testing.assert_array_equal(household.get_member_ages(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_ages.", verbose=True)
    check_phrase('member_ages', household.get_member_ages(), passed=True)

    assert household.get_reference_uid() is None, check_phrase('reference_uid', household.get_reference_uid(), passed=False)
    check_phrase('reference_uid', household.get_reference_uid(), passed=True)

    assert household.get_reference_age() is None, check_phrase('reference_age', household.get_reference_age(), passed=False)
    check_phrase('reference_age', household.get_reference_age(), passed=True)

    print('Checks passed for an empty household.')



def test_make_household():
    sp.logger.info("Test creating a household after the fact.")
    pop = sp.Pop(**pars)

    pop.household = sp.Household()
    pop.household.set_household(member_uids=pop.homes_by_uids[0], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[0]],
                                reference_uid=min(pop.homes_by_uids[0]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[0])],
                                hhid=0)

    assert pop.household.get_hhid() == 0, f"Check failed. pop.household hhid is {pop.household.get_hhid()}."
    print('Check passed. pop.household hhid is 0.')

    assert len(pop.household.get_member_uids()) > 0 and isinstance(pop.household.get_member_uids(), np.ndarray), 'Check failed: member_uids is empty or not a np.array.'
    print('Check passed. pop.household member_uids is an np.array and has at least one entry.')

    assert len(pop.household.get_member_ages()) > 0 and isinstance(pop.household.get_member_ages(), np.ndarray), 'Check failed: member_ages is empty or not a np.array.'
    print('Check passed. pop.household member_ages is an np.array and has at least one entry.')

    assert pop.household.get_reference_uid() is not None, 'Check failed. pop.household reference_uid is None.'
    print(f"Check passed. pop.household reference_uid is not None and instead is {pop.household.get_reference_uid()}.")

    assert pop.household.get_reference_age() is not None, 'Check failed. pop.household reference_age is None.'
    print(f"Check passed. pop.household reference_age is not None and instead is {pop.household.get_reference_age()}.")

    assert pop.household.get_household_size() > 0, f"Check failed. pop.household size is {pop.household.get_household_size()}."
    print(f"Check passed. pop.household household size is {pop.household.get_household_size()}.")


@pytest.mark.skip
def test_households_basic():
    sp.logger.info("Test creating generic households.")
    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid_dic = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}

    hhs = sp.Households(**{'households': homes_by_uids,
                           'age_by_uid': age_by_uid_dic})

    assert hhs.n_households == len(homes_by_uids), "number of household should match."

    for i in range(0, len(homes_by_uids)):
        assert hhs.get_household(i).get_reference_uid() == homes_by_uids[i][0]
        assert hhs.get_household(i).get_reference_age() == age_by_uid_dic[homes_by_uids[i][0]]
        assert hhs.get_household(i).get_household_size() == len(homes_by_uids[i])

    print('Check passed. Generic households can be populated during class initialization.')


@pytest.mark.skip  # necessary for vital dynamics but not working right now
def test_reset_household_values():
    sp.logger.info("Test resetting household values. Warning these features should only be available when synthpops is set to use vital dynamics.")
    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid_dic = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}
    hhs = sp.Households(**{'households': homes_by_uids,
                           'age_by_uid': age_by_uid_dic})
    hhs.get_household(0).set_hhid(7)
    hhs.get_household(0).set_member_uids([8, 8, 8])
    hhs.get_household(0).set_member_ages([0, 0, 0])
    hhs.get_household(0).set_reference_uid(8)
    hhs.get_household(0).set_reference_age(0)
    print(hhs.get_household(0))


def test_households_initialization():
    sp.logger.info("Test households initialization methods.")
    households = sp.Households()
    households.households = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    households.n_households = 2
    assert households.n_households != len(households.households), 'Check households.n_households and len(households.households) are not aligned.'
    print('Check passed. Initially households.n_households do not match len(households.households).')
    households.initialize_n_households()
    assert households.n_households == len(households.households), 'Check households.n_households and len(households.households) match.'
    print('Check passed. Now households.n_households and len(households.households).')

    households.households = []
    households.initialize_empty_households(n_households=5)
    for i in range(households.n_households):
        assert isinstance(households.households[i], sp.Household) and households.get_household(i).get_hhid() is None, 'Check failed. households[i] is not a household object.'
    print(f'Check passed. Initialized {households.n_households} empty households.')


if __name__ == '__main__':
    # pop = test_empty_household()
    test_make_household()
    pop = sp.Pop(**pars)
    # print(pop.homes_by_uids)
    pop.household = sp.Household()

    pop.household.set_household(member_uids=pop.homes_by_uids[0], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[0]],
                                reference_uid=min(pop.homes_by_uids[0]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[0])], hhid=0)
    print(pop.household)

    # pop.household2 = sp.Household(**dict(member_uids=pop.homes_by_uids[1], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[1]],
    #                                      reference_uid=min(pop.homes_by_uids[1]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[1])], hhid=1))
    # print(pop.household2)
    # # test_cannot_change_attribute()

    # # pop.households = sp.Households(**{'households': pop.household})
    pop.households = sp.Households()
    with pytest.raises(ValueError) as excinfo:
        pop.households.add_household('0')

    # print(pop.households)
    # # # pop.households = sp.Households(**{'households': pop.homes})
    # pop.households.initialize_empty_households(n_households=3)
    # print(pop.households)
    # # # print(pop.households.households)

    # test_households_initialization()
    test_households_basic()


    # pop.households.populate_households(pop.homes_by_uids[0:3], pop.age_by_uid)
    # print(pop.households.households)

    # print(pop.households.get_household(0))
    # print(pop.households.get_household(2))

    # school = sp.School()
    # school.set_school(**{'scid': 0})
    # print(school)
    # school.__setitem__('students', [0, 9])
    # school.set_item('students', [0, 9])
    # print(school)
    # school.set_school(**{'students': [0, 9]})
    # print(school)

    # h = sp.Household()
    # print(h)
    # print(type(h))

    # for nh, home_ids in enumerate(pop.homes_by_uids[0:2]):
    #     hkwargs = dict(hhid=nh, member_uids=home_ids, member_ages=pop.homes[nh], reference_uid=home_ids[0], reference_age=pop.homes[nh][0])
    #     h = sp.Household()
    #     h.set_household(**hkwargs)

    #     # print(h.get_household_size())
    #     # print(h)

    # pop.households.populate_households(pop.homes_by_uids[0:2], pop.age_by_uid)

    # print(pop.households)
    # for h in pop.households.household_list:
    #     print(h)

    # pop.pop_item('homes_by_uids')  # pop a bunch of unnecessary items once the population has been generated and stored in the right classes

    # cvpopdict = cv.make_synthpop(population=sc.dcp(pop.popdict), community_contacts=2)

    # # print(cvpopdict.keys())
    # people_pars = dict(pop_size=pars.n, beta_layer={k: 1. for k in 'hswcl'}, beta=1.)
    # people = cv.People(people_pars, uid=cvpopdict['uid'], age=cvpopdict['age'])

    # print(people)
    # print(type(people))
