"""
Test that school sizes are being generated by school type when with_school_types is turned on and data is available.
"""

import sciris as sc
import synthpops as sp
import numpy as np
import matplotlib as mplt
import matplotlib.pyplot as plt
import cmasher as cmr
import cmocean
import pytest

import covasim as cv

mplt.rcParams['font.family'] = 'Roboto Condensed'
mplt.rcParams['font.size'] = 7


# parameters to generate a test population
pars = sc.objdict(
    n                               = 5e1,
    rand_seed                       = 123,

    country_location                = 'usa',
    state_location                  = 'Washington',
    location                        = 'seattle_metro',
    use_default                     = True,

    smooth_ages                     = True,
    window_length                   = 7,
    household_method                = 'infer_ages',

    with_industry_code              = 0,
    with_facilities                 = 0,
    with_non_teaching_staff         = 1,
    use_two_group_reduction         = 1,
    with_school_types               = 1,

    school_mixing_type              = {'pk': 'age_and_class_clustered', 'es': 'age_and_class_clustered', 'ms': 'age_and_class_clustered', 'hs': 'random', 'uv': 'random'},  # you should know what school types you're working with
)


# def test_cannot_change_attribute():
#     sp.logger.info("Test to show that class methods can't be easily reset.")
#     pop = sp.Pop(**pars)
#     household = sp.Household()
#     # with pytest.raises(ValueError) as excinfo:
#     #     household.set_household = 1
#     # assert "exists as an attribute, so cannot be set as key; use setattribute() instead" in str(excinfo.value), 'Check that you cannot reset an attribute or household class method failed.'
#     print('Check passed. Could not reset household class method as an integer.')

#     # households = sp.Households()
#     # with pytest.raises(ValueError) as excinfo:
#     #     households.add_household = 2
#     # assert "exists as an attribute, so cannot be set as key; use setattribute() instead" in str(excinfo.value), 'Check that you cannot reset an attribute or households class method failed.'
#     print('Check passed. Could not reset households class method as an integer.')


def test_empty_household():
    sp.logger.info("Test creating an empty household.")

    household = sp.Household()

    def check_phrase(key, value, passed):
        print(f"Check {'passed' if passed else 'failed'}. household {key} for an empty household is {value}.")
        assert passed
        # if passed:
        #     print(f"Check passed. household {key} for an empty household is {value}.")
        # else:
        #     print(f"Check failed. household {key} for an empty household is {value}.")
    check_phrase('hhid', household['hhid'], passed=household['hhid'] is None)

    # assert household.get_hhid() is None, check_phrase('hhid', household.get_hhid(), passed=False)
    # check_phrase('hhid', household.get_hhid(), passed=True)
    # assert household['hhid'] is None, check_phrase('hhid', household['hhid'], passed=False)
    # check_phrase('hhid', household['hhid'], passed=True)

    # np.testing.assert_array_equal(household.get_member_uids(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_uids.", verbose=True)
    # check_phrase('member_uids', household.get_member_uids(), passed=True)
    np.testing.assert_array_equal(household['member_uids'], np.array([], dtype=int), err_msg="Check failed: empty array not found for member_uids.", verbose=True)
    check_phrase('member_uids', household['member_uids'], passed=True)

    # np.testing.assert_array_equal(household.get_member_ages(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_ages.", verbose=True)
    # check_phrase('member_ages', household.get_member_ages(), passed=True)
    np.testing.assert_array_equal(household['member_ages'], np.array([], dtype=int), err_msg="Check failed: empty array not found for member_ages.", verbose=True)
    check_phrase('member_ages', household['member_ages'], passed=True)

    # assert household.get_reference_uid() is None, check_phrase('reference_uid', household.get_reference_uid(), passed=False)
    # check_phrase('reference_uid', household.get_reference_uid(), passed=True)
    # assert household['reference_uid'] is None, check_phrase('reference_uid', household['reference_uid'], passed=False)
    # check_phrase('reference_uid', household['reference_uid'], passed=True)
    check_phrase('reference_uid', household['reference_uid'], passed=household['reference_uid'] is None)

    # assert household.get_reference_age() is None, check_phrase('reference_age', household.get_reference_age(), passed=False)
    # check_phrase('reference_age', household.get_reference_age(), passed=True)
    # assert household['reference_age'] is None, check_phrase('reference_age', household['reference_age'], passed=False)
    # check_phrase('reference_age', household['reference_age'], passed=True)
    check_phrase('reference_age', household['reference_age'], passed=household['reference_age'] is None)

    print('Checks passed for an empty household.')

# @pytest.mark.skip
def test_make_household():
    sp.logger.info("Test creating a household after the fact.")
    pop = sp.Pop(**pars)

    # we don't need to store this in the pop object but this shows that we can
    # and now the tests are being run using data stored in the pop object (pop.homes_by_uids, pop.age_by_uid)
    household = sp.Household()
    household.set_household(member_uids=pop.homes_by_uids[0], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[0]],
                            reference_uid=min(pop.homes_by_uids[0]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[0])],
                            hhid=0)

    # assert household.get_hhid() == 0, f"Check failed. household hhid is {household.get_hhid()}."
    assert household['hhid'] == 0, f"Check failed. household hhid is {household['hhid']}."
    print('Check passed. household hhid is 0.')

    # assert len(household.get_member_uids()) > 0 and isinstance(household.get_member_uids(), (list, np.ndarray)), 'Check failed: member_uids is empty or not a np.array.'
    # assert len(household['member_uids']) > 0 and isinstance(household['member_uids'], (list, np.ndarray)), 'Check failed: member_uids is empty or not a np.array.'
    # print('Check passed. household member_uids is an np.array and has at least one entry.')

    # assert len(household.get_member_ages()) > 0 and isinstance(household.get_member_ages(), (list, np.ndarray)), 'Check failed: member_ages is empty or not a np.array.'
    # assert len(household['member_ages']) > 0 and isinstance(household['member_ages'], (list, np.ndarray)), 'Check failed: member_ages is empty or not a np.array.'
    # print('Check passed. household member_ages is an np.array and has at least one entry.')

    assert len(household['member_uids']) == len(household['member_ages']), 'Check failed: member_uids and member_ages have different lengths.'
    print(f"Check passed. household member_uids and member_ages have the same length ({len(household['member_uids'])}).")

    assert len(household) == len(household['member_uids']), 'Check failed: len(household) does not return the household size, i.e. the number of household members.'
    print(f"Check passed. len(household) returns the number of household members.")

    # assert household.get_reference_uid() is not None, 'Check failed. household reference_uid is None.'
    assert household['reference_uid'] is not None, 'Check failed. household reference_uid is None.'
    print(f"Check passed. household reference_uid is not None and instead is {household['reference_uid']}.")

    # assert household.get_reference_age() is not None, 'Check failed. household reference_age is None.'
    assert household['reference_age'] is not None, 'Check failed. household reference_age is None.'
    print(f"Check passed. household reference_age is not None and instead is {household['reference_age']}.")

    # assert household.get_household_size() > 0, f"Check failed. household size is {household.get_household_size()}."
    assert len(household), f"Check failed. household size is {len(household)}."
    print(f"Check passed. household household size is {len(household)}.")


def test_add_household():
    sp.logger.info("Test creating a sp.Household object and adding it to an empty sp.Households class after generation.")
    home = [1, 2, 3]
    age_by_uid = {1: 88, 2: 45, 3: 47}
    household = sp.Household(member_uids=home, member_ages=[age_by_uid[i] for i in home],
                             reference_uid=home[0], reference_age=age_by_uid[home[0]],
                             hhid=0)

    assert isinstance(household, sp.Household), 'Check failed. Not a sp.Household object.'

    pop = sc.prettyobj()
    pop.households = []
    sp.add_household(pop, household)

    # assert isinstance(households.households_array[0], sp.Household), 'Check failed. Did not add a sp.Household object to the list of households.'
    assert isinstance(pop.households[0], sp.Household), 'Check failed. Did not add a sp.Household object to the list of households.'
    print('Check passed. Added a sp.Household object to an sp.Households object.')


def test_households_basic():
    sp.logger.info("Test creating generic households.")
    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}

    pop = sc.prettyobj()
    pop.households = []
    sp.populate_households(pop, homes_by_uids, age_by_uid)

    # households = sp.Households(**{'households': homes_by_uids,
    #                               'age_by_uid': age_by_uid})

    # assert households.n_households == len(homes_by_uids), "number of households should match."
    assert pop.n_households == len(homes_by_uids), "number of households should match."
    for i in range(0, len(homes_by_uids)):
        assert pop.households[i]['reference_uid'] == homes_by_uids[i][0]
        assert pop.households[i]['reference_age'] == age_by_uid[homes_by_uids[i][0]]
        assert len(pop.households[i]) == len(homes_by_uids[i])
        # assert households.get_household(i)['reference_uid'] == homes_by_uids[i][0]
        # assert households.get_household(i)['reference_age'] == age_by_uid[homes_by_uids[i][0]]
        # assert len(households.get_household(i)) == len(homes_by_uids[i])
    print('Check passed. Generic households can be populated during class initialization.')

    not_a_household = ''
    with pytest.raises(ValueError):
        sp.add_household(pop, not_a_household)
        # households.add_household(not_a_household)
    # print('Check passed. Cannot add an object that is not a sp.Household to a sp.Households object.')
    print('Check passed. Cannot add an object that is not a sp.Household using sp.add_household().')


@pytest.mark.skip  # necessary for vital dynamics but not working right now
def test_reset_household_values():
    sp.logger.info("Test resetting household values. Warning these features should only be available when synthpops is set to use vital dynamics.")
    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}
    pop = sc.prettyobj()
    pop.households = []
    sp.populate_households(pop, homes_by_uids, age_by_uid)
    # households = sp.Households(**{'households': homes_by_uids,
    #                               'age_by_uid': age_by_uid})
    # households.get_household(0).set_hhid(7)
    # households.get_household(0).set_member_uids([8, 8, 8])
    # households.get_household(0).set_member_ages([0, 0, 0])
    # households.get_household(0).set_reference_uid(8)
    # households.get_household(0).set_reference_age(0)


def test_households_initialization():
    sp.logger.info("Test households initialization methods.")

    # households = sp.Households()
    pop = sc.prettyobj()
    pop.households = []

    # test no households made
    sp.initialize_empty_households(pop)
    assert pop.n_households == 0, 'Check failed. households.n_households is not 0.'
    print('Check passed. Initially without any households information, households.n_households is 0.')

    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}

    pop.households = homes_by_uids
    pop.n_households = 2

    # households.households_array = homes_by_uids
    # households.n_households = 2
    assert pop.n_households != len(pop.households), 'Check failed. pop.n_households and len(pop.households_array) are not aligned.'
    print('Check passed. Initially households.n_households do not match len(households.households_array).')

    # households.initialize_n_households()
    # assert households.n_households == len(households.households_array), 'Check failed. households.n_households and len(households.households_array) do not match.'
    # print('Check passed. Now households.n_households and len(households.households_array).')

    pop.households = []
    sp.initialize_empty_households(pop, n_households=5)
    for i in range(pop.n_households):
        # assert isinstance(households.households_array[i], sp.Household) and households.get_household(i).get_hhid() is None, 'Check failed. households[i] is not a household object.'
        assert isinstance(pop.households[i], sp.Household) and pop.households[i]['hhid'] is None, 'Check failed. households[i] is not a household object.'
    print(f'Check passed. Initialized {pop.n_households} empty households.')

    # test that if there are not enough households when populating, we reinitialize that cover with the correct number
    # households.households_array = []
    pop.households = []
    sp.populate_households(pop, homes_by_uids, age_by_uid)
    assert len(pop.households) == len(homes_by_uids), 'Check failed.'
    print('Check passed.')


if __name__ == '__main__':

    test_cannot_change_attribute()
    pop = test_empty_household()
    test_make_household()
    test_add_household()
    test_households_basic()
    test_households_initialization()

    hhs = sp.Households()
    # print(hhs.keys())

