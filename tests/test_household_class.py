"""
Test that school sizes are being generated by school type when with_school_types is turned on and data is available.
"""

import sciris as sc
import synthpops as sp
import numpy as np
import matplotlib as mplt
import matplotlib.pyplot as plt
import cmasher as cmr
import cmocean
import pytest

import covasim as cv

mplt.rcParams['font.family'] = 'Roboto Condensed'
mplt.rcParams['font.size'] = 7


# parameters to generate a test population
pars = sc.objdict(
    n                               = 5e1,
    rand_seed                       = 123,

    country_location                = 'usa',
    state_location                  = 'Washington',
    location                        = 'seattle_metro',
    use_default                     = True,

    smooth_ages                     = True,
    window_length                   = 7,
    household_method                = 'infer_ages',

    with_industry_code              = 0,
    with_facilities                 = 0,
    with_non_teaching_staff         = 1,
    use_two_group_reduction         = 1,
    with_school_types               = 1,

    school_mixing_type              = {'pk': 'age_and_class_clustered', 'es': 'age_and_class_clustered', 'ms': 'age_and_class_clustered', 'hs': 'random', 'uv': 'random'},  # you should know what school types you're working with
)


def test_cannot_change_attribute():
    sp.logger.info("Test to show that class methods can't be easily reset.")
    pop = sp.Pop(**pars)
    pop.household = sp.Household()
    with pytest.raises(ValueError) as excinfo:
        pop.household.set_household = 1
    assert "exists as an attribute, so cannot be set as key; use setattribute() instead" in str(excinfo.value), 'Check that you cannot reset an attribute or household class method failed.'
    print('Check passed. Could not reset household class method as an integer.')

    pop.households = sp.Households()
    with pytest.raises(ValueError) as excinfo:
        pop.households.add_household = 2
    assert "exists as an attribute, so cannot be set as key; use setattribute() instead" in str(excinfo.value), 'Check that you cannot reset an attribute or households class method failed.'
    print('Check passed. Could not reset households class method as an integer.')


def test_empty_household():
    sp.logger.info("Test creating an empty household.")

    household = sp.Household()

    def check_phrase(key, value, passed):
        if passed:
            print(f"Check passed. household {key} for an empty household is {value}.")
        else:
            print(f"Check failed. household {key} for an empty household is {value}.")

    assert household.get_hhid() is None, check_phrase('hhid', household.get_hhid(), passed=False)
    check_phrase('hhid', household.get_hhid(), passed=True)

    np.testing.assert_array_equal(household.get_member_uids(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_uids.", verbose=True)
    check_phrase('member_uids', household.get_member_uids(), passed=True)

    np.testing.assert_array_equal(household.get_member_ages(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_ages.", verbose=True)
    check_phrase('member_ages', household.get_member_ages(), passed=True)

    assert household.get_reference_uid() is None, check_phrase('reference_uid', household.get_reference_uid(), passed=False)
    check_phrase('reference_uid', household.get_reference_uid(), passed=True)

    assert household.get_reference_age() is None, check_phrase('reference_age', household.get_reference_age(), passed=False)
    check_phrase('reference_age', household.get_reference_age(), passed=True)

    print('Checks passed for an empty household.')


def test_make_household():
    sp.logger.info("Test creating a household after the fact.")
    pop = sp.Pop(**pars)

    # we don't need to store this in the pop object but this shows that we can
    # and now the tests are being run using data stored in the pop object (pop.homes_by_uids, pop.age_by_uid)
    pop.household = sp.Household()
    pop.household.set_household(member_uids=pop.homes_by_uids[0], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[0]],
                                reference_uid=min(pop.homes_by_uids[0]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[0])],
                                hhid=0)

    assert pop.household.get_hhid() == 0, f"Check failed. pop.household hhid is {pop.household.get_hhid()}."
    print('Check passed. pop.household hhid is 0.')

    assert len(pop.household.get_member_uids()) > 0 and isinstance(pop.household.get_member_uids(), np.ndarray), 'Check failed: member_uids is empty or not a np.array.'
    print('Check passed. pop.household member_uids is an np.array and has at least one entry.')

    assert len(pop.household.get_member_ages()) > 0 and isinstance(pop.household.get_member_ages(), np.ndarray), 'Check failed: member_ages is empty or not a np.array.'
    print('Check passed. pop.household member_ages is an np.array and has at least one entry.')

    assert pop.household.get_reference_uid() is not None, 'Check failed. pop.household reference_uid is None.'
    print(f"Check passed. pop.household reference_uid is not None and instead is {pop.household.get_reference_uid()}.")

    assert pop.household.get_reference_age() is not None, 'Check failed. pop.household reference_age is None.'
    print(f"Check passed. pop.household reference_age is not None and instead is {pop.household.get_reference_age()}.")

    assert pop.household.get_household_size() > 0, f"Check failed. pop.household size is {pop.household.get_household_size()}."
    print(f"Check passed. pop.household household size is {pop.household.get_household_size()}.")


def test_add_household():
    sp.logger.info("Test creating a sp.Household object and adding it to an empty sp.Households class after generation.")
    home = [1, 2, 3]
    age_by_uid = {1: 88, 2: 45, 3: 47}
    household = sp.Household(member_uids=home, member_ages=[age_by_uid[i] for i in home],
                             reference_uid=home[0], reference_age=age_by_uid[home[0]],
                             hhid=0)

    assert isinstance(household, sp.Household), 'Check failed. Not a sp.Household object.'

    households = sp.Households()
    households.add_household(household)

    assert isinstance(households.households[0], sp.Household), 'Check failed. Did not add a sp.Household object to the list of households.'
    print('Check passed. Added a sp.Household object to an sp.Households object.')


def test_households_basic():
    sp.logger.info("Test creating generic households.")
    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}

    hhs = sp.Households(**{'households': homes_by_uids,
                           'age_by_uid': age_by_uid})

    assert hhs.n_households == len(homes_by_uids), "number of household should match."

    for i in range(0, len(homes_by_uids)):
        assert hhs.get_household(i).get_reference_uid() == homes_by_uids[i][0]
        assert hhs.get_household(i).get_reference_age() == age_by_uid[homes_by_uids[i][0]]
        assert hhs.get_household(i).get_household_size() == len(homes_by_uids[i])
    print('Check passed. Generic households can be populated during class initialization.')

    not_a_household = ''
    with pytest.raises(ValueError) as excinfo:
        hhs.add_household(not_a_household)
    print('Check passed. Cannot add an object that is not a sp.Household to a sp.Households object.')


@pytest.mark.skip  # necessary for vital dynamics but not working right now
def test_reset_household_values():
    sp.logger.info("Test resetting household values. Warning these features should only be available when synthpops is set to use vital dynamics.")
    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}
    hhs = sp.Households(**{'households': homes_by_uids,
                           'age_by_uid': age_by_uid})
    hhs.get_household(0).set_hhid(7)
    hhs.get_household(0).set_member_uids([8, 8, 8])
    hhs.get_household(0).set_member_ages([0, 0, 0])
    hhs.get_household(0).set_reference_uid(8)
    hhs.get_household(0).set_reference_age(0)


def test_households_initialization():
    sp.logger.info("Test households initialization methods.")

    households = sp.Households()

    # test no households made
    households.initialize_empty_households()
    assert households.n_households == 0, 'Check failed. households.n_households is not 0.'
    print('Check passed. Initially without any households information, households.n_households is 0.')

    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}

    households.households = homes_by_uids
    households.n_households = 2
    assert households.n_households != len(households.households), 'Check households.n_households and len(households.households) are not aligned.'
    print('Check passed. Initially households.n_households do not match len(households.households).')
    households.initialize_n_households()
    assert households.n_households == len(households.households), 'Check households.n_households and len(households.households) match.'
    print('Check passed. Now households.n_households and len(households.households).')

    households.households = []
    households.initialize_empty_households(n_households=5)
    for i in range(households.n_households):
        assert isinstance(households.households[i], sp.Household) and households.get_household(i).get_hhid() is None, 'Check failed. households[i] is not a household object.'
    print(f'Check passed. Initialized {households.n_households} empty households.')

    # test that if there are not enough households when populating, we reinitialize that cover with the correct number
    households.households = []
    households.populate_households(homes_by_uids, age_by_uid)
    assert len(households.households) == len(homes_by_uids), 'Check failed.'
    print('Check passed.')


if __name__ == '__main__':

    test_cannot_change_attribute()
    pop = test_empty_household()
    test_make_household()
    test_add_household()
    test_households_basic()
    test_households_initialization()
