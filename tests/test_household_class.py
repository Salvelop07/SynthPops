"""
Test that school sizes are being generated by school type when with_school_types is turned on and data is available.
"""

import sciris as sc
import synthpops as sp
import numpy as np
import matplotlib as mplt
import matplotlib.pyplot as plt
import cmasher as cmr
import cmocean
import pytest

import covasim as cv

mplt.rcParams['font.family'] = 'Roboto Condensed'
mplt.rcParams['font.size'] = 7


# parameters to generate a test population
pars = sc.objdict(
    n                               = 5e1,
    rand_seed                       = 123,

    country_location                = 'usa',
    state_location                  = 'Washington',
    location                        = 'seattle_metro',
    use_default                     = True,

    smooth_ages                     = True,
    window_length                   = 7,
    household_method                = 'infer_ages',

    with_industry_code              = 0,
    with_facilities                 = 0,
    with_non_teaching_staff         = 1,
    use_two_group_reduction         = 1,
    with_school_types               = 1,

    school_mixing_type              = {'pk': 'age_and_class_clustered', 'es': 'age_and_class_clustered', 'ms': 'age_and_class_clustered', 'hs': 'random', 'uv': 'random'},  # you should know what school types you're working with
)


@pytest.mark.skip
def test_household_basic():
    homes_by_uids = [[1, 2, 3], [4], [7, 6, 5, 8, 9]]
    age_by_uid_dic = {1: 88, 2: 45, 3: 47, 4: 38, 5: 12, 6: 19, 7: 55, 8: 58, 9: 99}
    hhs = sp.Households(**{'households': homes_by_uids,
                           'age_by_uid': age_by_uid_dic})
    assert hhs.n_households == len(homes_by_uids), "number of household should match."
    for i in range(0, len(homes_by_uids)):
        assert hhs.get_household(i).get_reference_pid() == homes_by_uids[i][0]
        assert hhs.get_household(i).get_reference_age() == age_by_uid_dic[homes_by_uids[i][0]]
        assert hhs.get_household(i).get_household_size() == len(homes_by_uids[i])


def test_cannot_change_attribute():
    sp.logger.info("Test to show that class methods can't be easily reset.")
    pop = sp.Pop(**pars)
    pop.household = sp.Household()
    with pytest.raises(ValueError) as excinfo:
        pop.household.set_household = 1
    assert "exists as an attribute, so cannot be set as key; use setattribute() instead" in str(excinfo.value), 'Check that you cannot reset an attribute or household class method failed.'
    print('Check passed. Could not reset household class method as an integer.')


def test_empty_household():
    sp.logger.info("Test creating an empty household.")

    pop = sp.Pop(**pars)

    pop.household = sp.Household()
    assert pop.household.get_hhid() is None, f"Check failed. pop.household hhid is {pop.household.get_hhid()}"
    print(f"Check passed. pop.household hhid is {pop.household.get_hhid()}")
    np.testing.assert_array_equal(pop.household.get_member_pids(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_pids.", verbose=True)
    print("Check passed. pop.household member_pids is an empty np.array")
    np.testing.assert_array_equal(pop.household.get_member_ages(), np.array([], dtype=int), err_msg="Check failed: empty array not found for member_ages.", verbose=True)
    print("Check passed. pop.household member_ages is an empty np.array")
    assert pop.household.get_reference_pid() is None, f"Check failed. pop.household reference_pid is {pop.household.get_reference_pid()}."
    assert pop.household.get_reference_age() is None, f"Check failed. pop.household reference_age is {pop.household.get_reference_age()}."

    print('Checks passed for an empty household.')

    return pop


def test_make_household():
    sp.logger.info("Test creating a household after the fact.")
    pop = sp.Pop(**pars)

    pop.household = sp.Household()
    pop.household.set_household(member_pids=pop.homes_by_uids[0], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[0]],
                                reference_pid=min(pop.homes_by_uids[0]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[0])],
                                hhid=0)
    assert pop.household.get_hhid() == 0, f"Check failed. pop.household hhid is {pop.household.get_hhid()}."
    assert len(pop.household.get_member_pids()) > 0 and isinstance(pop.household.get_member_pids(), np.ndarray), 'Check failed: member_pids is empty or not a np.array.'
    assert len(pop.household.get_member_ages()) > 0 and isinstance(pop.household.get_member_ages(), np.ndarray), 'Check failed: member_ages is empty or not a np.array.'
    assert pop.household.get_reference_pid() is not None, 'Check failed. pop.household reference_pid is None.'
    assert pop.household.get_reference_age() is not None, 'Check failed. pop.household reference_age is None.'
    assert pop.household.get_hhid() is not None, 'Check failed. pop.household hhid is None.'
    assert pop.household.get_household_size() > 0, f"Check failed. pop.household size is {pop.household.get_household_size()}."





if __name__ == '__main__':

    # pop = test_empty_household()
    test_make_household()
    pop = sp.Pop(**pars)
    print(pop.homes_by_uids)

    pop.household = sp.Household()

    pop.household.set_household(member_pids=pop.homes_by_uids[0], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[0]],
                                reference_pid=min(pop.homes_by_uids[0]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[0])], hhid=0)
    print(pop.household)

    pop.household2 = sp.Household(**dict(member_pids=pop.homes_by_uids[1], member_ages=[pop.age_by_uid[i] for i in pop.homes_by_uids[1]],
                                         reference_pid=min(pop.homes_by_uids[1]), reference_age=pop.age_by_uid[min(pop.homes_by_uids[1])], hhid=1))
    print(pop.household2)
    # test_cannot_change_attribute()

    # pop.households = sp.Households(**{'households': pop.household})
    pop.households = sp.Households()

    print(pop.households)

    # # pop.households = sp.Households(**{'households': pop.homes})
    pop.households.initialize_empty_households(n_households=3)
    # print('here')
    print(pop.households)
    # # print(pop.households.households)

    # pop.households.populate_households(pop.homes_by_uids[0:3], pop.age_by_uid)
    # print(pop.households.households)

    # print(pop.households.get_household(0))
    # print(pop.households.get_household(2))

    # school = sp.School()
    # school.set_school(**{'scid': 0})
    # print(school)
    # school.__setitem__('students', [0, 9])
    # school.set_item('students', [0, 9])
    # print(school)
    # school.set_school(**{'students': [0, 9]})
    # print(school)

    # h = sp.Household()
    # print(h)
    # print(type(h))

    # for nh, home_ids in enumerate(pop.homes_by_uids[0:2]):
    #     hkwargs = dict(hhid=nh, member_pids=home_ids, member_ages=pop.homes[nh], reference_pid=home_ids[0], reference_age=pop.homes[nh][0])
    #     h = sp.Household()
    #     h.set_household(**hkwargs)

    #     # print(h.get_household_size())
    #     # print(h)

    # pop.households.populate_households(pop.homes_by_uids[0:2], pop.age_by_uid)

    # print(pop.households)
    # for h in pop.households.household_list:
    #     print(h)

    # pop.pop_item('homes_by_uids')  # pop a bunch of unnecessary items once the population has been generated and stored in the right classes

    # cvpopdict = cv.make_synthpop(population=sc.dcp(pop.popdict), community_contacts=2)

    # # print(cvpopdict.keys())
    # people_pars = dict(pop_size=pars.n, beta_layer={k: 1. for k in 'hswcl'}, beta=1.)
    # people = cv.People(people_pars, uid=cvpopdict['uid'], age=cvpopdict['age'])

    # print(people)
    # print(type(people))
